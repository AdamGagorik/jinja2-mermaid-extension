{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#jinja2-mermaid-extension","title":"jinja2-mermaid-extension","text":"<p>A jinja2 block to render a mermaid or tikz diagram.</p> <ol> <li>Mermaid diagrams are rendered using the <code>mermaid-cli</code> tool in a <code>Docker</code> container.</li> <li>TikZ diagrams are rendered using the <code>tectonic</code> tool on your host machine.</li> <li>The diagram is saved to the current directory or <code>mermaid_output_root</code> or <code>tikz_output_root</code> (if defined).</li> <li>The block is then replaced with a configurable string (markdown, etc).</li> </ol>"},{"location":"#setup","title":"Setup","text":"<ul> <li><code>Docker</code> must be installed to run the <code>mermaid</code> command line tool.</li> <li>The extension should be installed in your <code>Python</code> environment.</li> <li><code>tectonic</code> must be installed to render <code>tikz</code> diagrams.</li> </ul> <pre><code>pip install jinja2-mermaid-extension\n</code></pre> <ul> <li>The extension should be added to the <code>jinja2</code> environment.</li> </ul> <pre><code>from jinja2 import Environment\nfrom jinja2_mermaid_extension import MermaidExtension\n\nenv = Environment(extensions=[MermaidExtension])\n</code></pre> <ul> <li>You should pass the <code>mermaid_output_root</code> to the render method.</li> </ul> <pre><code>out_path = Path().cwd() / \"example.md\"\ntemplate = env.get_template(\"example.md.jinja2\")\nrendered = template.render(mermaid_input_root=Path.cwd(), mermaid_output_root=out_path.parent)\nout_path.write_text(rendered)\n</code></pre>"},{"location":"#usage-mermaid","title":"Usage : mermaid","text":"<p>The following <code>jinaj2</code> block will render a mermaid diagram.</p> <pre><code>{% mermaid -%}\next: .png\nname: test\nmode: myst\nscale: 3\nwidth: 75\nalign: center\ncaption: |\n    An example mermaid diagram!\ndiagram: |\n    graph TD\n        A --&gt; B\n        B --&gt; C\n        A --&gt; C\n{% endmermaid %}\n</code></pre> <p>The output will be replaced with a <code>MyST</code> formatted markdown image.</p> <pre><code>:::{figure} test.png\n:align: center\n:witdh: 75\n\nAn example mermaid diagram!\n:::\n</code></pre> <p>The following arguments are available:</p> Argument Kind Description Default diagram or inp Input The raw mermaid diagram code or the path to an <code>mmd</code> file. <code>None</code> ext Output The file extension of the generated diagram. <code>\".png\"</code> mode Replacement Option How to render the output after processing. <code>\"path\"</code> alt_text Replacement Option The alt text of the diagram. <code>None</code> align Replacement Option The alignment of the diagram only valid for MyST output) <code>\"center\"</code> caption Replacement Option A caption to add to the diagram only valid for MyST output). <code>None</code> just_name Replacement Option Whether to only output the name of the generated diagram. <code>False</code> full_path Replacement Option Whether to output the full path of the generated diagram. <code>False</code> use_cached Processing Option Whether to use a cached version of the diagram. <code>True</code> parallel Processing Option Whether to render the diagram in parallel. <code>False</code> temp_dir Processing Option A temporary directory to use for intermediate files. <code>None</code> delete_temp_dir Processing Option Whether to delete the temporary directory after execution. <code>True</code> mermaid_docker_image Processing Option The docker image containing the mermaid-cli tool. <code>\"minlag/mermaid-cli\"</code> mermaid_volume_mount Processing Option The directory in the docker container to mount the temporary directory to. <code>\"/data\"</code> use_local_mmdc_instead Processing Option Whether to use the docker image or a locally installed mermaid-cli tool named mmdc. <code>False</code> <p>The following mermaid specific arguments are available:</p> Argument Kind Description Default theme Mermaid CLI Option The theme to use for the diagram. <code>\"default\"</code> scale Mermaid CLI Option A scaling factor for the diagram. <code>3</code> width Mermaid CLI Option The width of the diagram in pixels. <code>800</code> height Mermaid CLI Option The height of the diagram in pixels. <code>None</code> background Mermaid CLI Option The background color of the generated diagram. <code>\"white\"</code> <p>The block will be replaced by a string based on the <code>mode</code> argument.</p> <ul> <li><code>path</code>: Output the path to the generated image.</li> <li><code>markdown</code>: Output a simple markdown image link.</li> <li><code>restructured</code>: Output a restructured text image link.</li> <li><code>myst_markdown</code>: Output a MyST formatted markdown image.</li> </ul> <p>For example, when using <code>mode: markdown</code>, the example above will be replaced with:</p> <pre><code>![An example mermaid diagram!](./test.png)\n</code></pre>"},{"location":"#usage-tikz","title":"Usage : tikz","text":"<p>The following <code>jinaj2</code> block will render a <code>tikz</code> diagram (any LaTeX document really).</p> <pre><code>{% tikz -%}\next: .pdf\nname: test\nmode: path\ndiagram: |\n    \\documentclass[margin=0pt]{standalone}\n    \\usepackage{tikz}\n    \\begin{document}\n    \\begin{tikzpicture}[remember picture]\n    \\coordinate (SE) at (0,0) {};\n    \\coordinate (NW) at (5,5) {};\n    \\draw (SE) rectangle (NW);\n    \\node[draw, rectangle, anchor=south west] at (SE) {SE};\n    \\node[draw, rectangle, anchor=north east] at (NW) {NW};\n    \\end{tikzpicture}\n    \\end{document}\n{% endtikz %}\n</code></pre> <p>The following tikz specific arguments are available:</p> Argument Kind Description Default allow_missing TikZ Option Allow commands to be missing? <code>False</code> latex_command TikZ Option The command to use to compile tikz diagrams. <code>\"tectonic {inp_tex}\"</code> pdf2svg_command TikZ Option The command to use to convert pdf to svg diagrams. <code>\"pdf2svg {inp_pdf} {out_svg}\"</code> convert_command TikZ Option The command to use to convert pdf to png diagrams. <code>\"magick convert {inp_pdf} {out_png}\"</code> convert_command_density TikZ Option The density of the png diagram. <code>300</code> package TikZ Option The LaTeX package to use for the diagram. <code>(xcolor, tikz)</code> preable TikZ Option The LaTeX preable to use for the diagram. `` libraries TikZ Option The TikZ libraries to use for the diagram. <code>(shapes, arrows, etc)</code> tikz_options TikZ Option The TikZ picture options to use for the diagram. <code>(scale=1, remember picture)</code> <ul> <li>Github repository: https://github.com/AdamGagorik/jinja2-mermaid-extension/</li> <li>Documentation https://AdamGagorik.github.io/jinja2-mermaid-extension/</li> </ul>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#jinja2_mermaid_extension.base--this-module-defines-a-base-class-for-jinja2-extensions-that-generate-images","title":"This module defines a base class for jinja2 extensions that generate images.","text":""},{"location":"modules/#jinja2_mermaid_extension.base.GenImageExtension","title":"<code>GenImageExtension</code>","text":"<p>             Bases: <code>Extension</code></p> Source code in <code>jinja2_mermaid_extension/base.py</code> <pre><code>class GenImageExtension(Extension):\n    tags: set[str] = {\"yaml\"}  # noqa: RUF012\n    input_root_key: str | None = None\n    output_root_key: str | None = None\n\n    def __init__(self, environment: Environment):\n        super().__init__(environment)\n\n    def parse(self, parser: Parser) -&gt; nodes.Node:\n        \"\"\"\n        The logic to parse the jinja2 block as yaml.\n        \"\"\"\n        line = next(parser.stream).lineno\n        block = parser.parse_statements((f\"name:end{next(iter(self.tags))}\",), drop_needle=True)\n        kwargs = yaml.safe_load(cast(nodes.TemplateData, cast(nodes.Output, block[0]).nodes[0]).data)\n        callback = self.call_method(\"_render\", [nodes.Const(json.dumps(kwargs))])\n        return nodes.CallBlock(callback, [], [], block).set_lineno(line)\n\n    @staticmethod\n    def modify(**kwargs: Any) -&gt; Generator[tuple[str, Any], None, None]:\n        \"\"\"\n        Intercept and modify the keyword arguments before passing them to the callback function.\n        \"\"\"\n        yield from kwargs.items()\n\n    def callback(self, inp: Path | str, out: Path, inp_root: Path, out_root: Path, **kwargs: Any) -&gt; None:\n        \"\"\"\n        The function to call to generate an image.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def _valid_keys(self) -&gt; Generator[str]:\n        yield from ()\n\n    @pass_context\n    def _render(self, context: Context, kwargs_json: str, caller: Macro) -&gt; str:\n        kwargs = dict(self.modify(**json.loads(kwargs_json)))\n        valid_keys = set(inspect.signature(self._gen_markdown_lines).parameters) | set(self._valid_keys)\n        valid_keys = valid_keys - {\"context\", \"output_name_salt\", \"out\"}\n        unknown_keys = set(kwargs.keys()) - valid_keys\n        if any(unknown_keys):\n            raise TypeError(f\"callback got unexpected keyword arguments: {', '.join(unknown_keys)}\")\n\n        return \"\\n\".join(self._gen_markdown_lines(context, output_name_salt=kwargs_json, **kwargs))\n\n    def _gen_markdown_lines(  # noqa: C901\n        self,\n        context: Context,\n        inp: Path | str,\n        ext: str = \".png\",\n        name: str | None = None,\n        mode: str | Mode = Mode.OUT,\n        width: int | str | None = None,\n        height: int | str | None = None,\n        align: str = \"center\",\n        caption: str | None = None,\n        full_path: bool = False,\n        just_name: bool = False,\n        use_cached: bool = True,\n        parallel: bool = False,\n        output_name_salt: str = \"...\",\n        **kwargs: Any,\n    ) -&gt; Generator[str, None, None]:\n        \"\"\"\n        Run callback and yield a series of markdown commands to include it .\n        \"\"\"\n        if isinstance(mode, str):\n            mode = LOOKUP_MODE[mode.strip().lower()]\n\n        out_root = self._get_output_root(context)\n        if name is None:\n            name = str(uuid5(namespace, str(inp) + output_name_salt))\n\n        out = out_root.joinpath(name).with_suffix(\".\" + ext.lower().lstrip(\".\"))\n\n        if not out.exists() or not use_cached:\n            if out in runner():\n                logger.warning(\"ignore: %s\", out)\n            else:\n                if parallel:\n                    logger.warning(\"submit: %s\", out)\n                    runner().run(\n                        key=out,\n                        fn=self.callback,\n                        inp=inp,\n                        out=out,\n                        inp_root=self._get_input_root(context),\n                        out_root=out_root,\n                        **kwargs,\n                    )\n                else:\n                    logger.warning(\"create: %s\", out)\n                    self.callback(\n                        inp=inp,\n                        out=out,\n                        inp_root=self._get_input_root(context),\n                        out_root=self._get_output_root(context),\n                        **kwargs,\n                    )\n                    runner().running.add(out)\n        else:\n            logger.warning(\"cached: %s\", out)\n\n        if just_name:\n            stem = out.name\n        elif not full_path:\n            stem = str(out.relative_to(Path(out_root)))\n        else:\n            stem = str(out)\n\n        if mode == Mode.OUT:\n            yield stem\n        elif mode == Mode.MD:\n            yield from self._render_md(out, stem, caption)\n        elif mode == Mode.RST:\n            yield from self._render_rst(stem, caption)\n        elif mode == Mode.MYST:\n            yield from self._render_myst(stem, align, caption, width, height)\n        else:\n            raise ValueError(f\"Unknown mode: {mode}\")\n\n    @classmethod\n    def _get_input_root(cls, context: Context) -&gt; Path:\n        if cls.input_root_key is None:\n            return Path.cwd()\n\n        if (root := context.parent.get(str(cls.input_root_key))) is None:\n            return Path.cwd()\n\n        return Path(cast(Path, root))\n\n    @classmethod\n    def _get_output_root(cls, context: Context) -&gt; Path:\n        if cls.output_root_key is None:\n            return Path.cwd()\n\n        if (root := context.parent.get(str(cls.output_root_key))) is None:\n            return Path.cwd()\n\n        return Path(cast(Path, root))\n\n    @staticmethod\n    def _render_md(out: Path, stem: str, caption: str | None) -&gt; Generator[str, None, None]:\n        if caption is not None:\n            caption = caption.rstrip()\n            yield f\"![{caption}]({stem})\"\n        else:\n            yield f\"![{out.name}]({stem})\"\n\n    @staticmethod\n    def _render_rst(stem: str, caption: str | None) -&gt; Generator[str, None, None]:\n        if caption is not None:\n            yield f\".. image:: {stem}\\n   :alt: {caption.rstrip()}\"\n        else:\n            yield f\".. image:: {stem}\"\n\n    @staticmethod\n    def _render_myst(\n        stem: str, align: str, caption: str | None, width: int | str | None, height: int | str | None\n    ) -&gt; Generator[str, None, None]:\n        if caption is not None:\n            yield f\":::{{figure}} {stem}\"\n        else:\n            yield f\":::{{image}} {stem}\"\n        if width is not None:\n            yield f\":width: {width}\"\n        if height is not None:\n            yield f\":height: {height}\"\n        if align is not None:\n            yield f\":align: {align}\"\n        if caption is not None:\n            yield f\"\\n{caption.rstrip()}\"\n        yield r\":::\"\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.base.GenImageExtension.callback","title":"<code>callback(inp, out, inp_root, out_root, **kwargs)</code>","text":"<p>The function to call to generate an image.</p> Source code in <code>jinja2_mermaid_extension/base.py</code> <pre><code>def callback(self, inp: Path | str, out: Path, inp_root: Path, out_root: Path, **kwargs: Any) -&gt; None:\n    \"\"\"\n    The function to call to generate an image.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.base.GenImageExtension.modify","title":"<code>modify(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Intercept and modify the keyword arguments before passing them to the callback function.</p> Source code in <code>jinja2_mermaid_extension/base.py</code> <pre><code>@staticmethod\ndef modify(**kwargs: Any) -&gt; Generator[tuple[str, Any], None, None]:\n    \"\"\"\n    Intercept and modify the keyword arguments before passing them to the callback function.\n    \"\"\"\n    yield from kwargs.items()\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.base.GenImageExtension.parse","title":"<code>parse(parser)</code>","text":"<p>The logic to parse the jinja2 block as yaml.</p> Source code in <code>jinja2_mermaid_extension/base.py</code> <pre><code>def parse(self, parser: Parser) -&gt; nodes.Node:\n    \"\"\"\n    The logic to parse the jinja2 block as yaml.\n    \"\"\"\n    line = next(parser.stream).lineno\n    block = parser.parse_statements((f\"name:end{next(iter(self.tags))}\",), drop_needle=True)\n    kwargs = yaml.safe_load(cast(nodes.TemplateData, cast(nodes.Output, block[0]).nodes[0]).data)\n    callback = self.call_method(\"_render\", [nodes.Const(json.dumps(kwargs))])\n    return nodes.CallBlock(callback, [], [], block).set_lineno(line)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback--this-module-defines-a-callback-function-for-generating-mermaid-diagrams","title":"This module defines a callback function for generating mermaid diagrams.","text":""},{"location":"modules/#jinja2_mermaid_extension.callback.MermaidCallback","title":"<code>MermaidCallback</code>","text":"<p>             Bases: <code>RunCommandInTempDir</code></p> <p>A callback function for generating mermaid diagrams.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>class MermaidCallback(RunCommandInTempDir):\n    \"\"\"\n    A callback function for generating mermaid diagrams.\n    \"\"\"\n\n    #: The extension for raw input files.\n    RAW_INPUT_EXT: ClassVar[str] = \".mmd\"\n    #: The valid extensions for output files.\n    VALID_OUT_EXT: ClassVar[frozenset[str]] = frozenset((\".svg\", \".png\", \".pdf\"))\n\n    def command(self, *, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; Generator[str, None, None]:\n        \"\"\"\n        Generate the command to run.\n\n        Args:\n            tmp_inp: The input file, located in the temporary directory.\n            tmp_out: The output file, located in the temporary directory.\n            tmp_root: The current temporary directory.\n            kwargs: Additional keyword arguments.\n\n        Yields:\n            str: The command strings that were generated.\n        \"\"\"\n        opts = MermaidOptions(**kwargs)\n\n        if opts.use_local_mmdc_instead:\n            yield \"mmdc\"\n        else:\n            yield \"docker\"\n            yield \"run\"\n            yield \"--rm\"\n            yield \"-v\"\n            yield f\"{tmp_root}:{opts.mermaid_volume_mount}\"\n            yield opts.mermaid_docker_image\n\n        yield \"-t\"\n        yield opts.theme\n        yield \"-b\"\n        yield opts.background\n        yield \"-s\"\n        yield str(opts.scale)\n        yield \"-w\"\n        yield str(opts.render_width)\n        yield from (() if opts.render_height is None else (\"-H\", str(opts.render_height)))\n        yield \"-i\"\n        yield tmp_inp.name\n        yield \"-o\"\n        yield tmp_out.name\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.MermaidCallback.command","title":"<code>command(*, tmp_inp, tmp_out, tmp_root, **kwargs)</code>","text":"<p>Generate the command to run.</p> <p>Parameters:</p> Name Type Description Default <code>tmp_inp</code> <code>Path</code> <p>The input file, located in the temporary directory.</p> required <code>tmp_out</code> <code>Path</code> <p>The output file, located in the temporary directory.</p> required <code>tmp_root</code> <code>Path</code> <p>The current temporary directory.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Yields:</p> Name Type Description <code>str</code> <code>str</code> <p>The command strings that were generated.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>def command(self, *, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; Generator[str, None, None]:\n    \"\"\"\n    Generate the command to run.\n\n    Args:\n        tmp_inp: The input file, located in the temporary directory.\n        tmp_out: The output file, located in the temporary directory.\n        tmp_root: The current temporary directory.\n        kwargs: Additional keyword arguments.\n\n    Yields:\n        str: The command strings that were generated.\n    \"\"\"\n    opts = MermaidOptions(**kwargs)\n\n    if opts.use_local_mmdc_instead:\n        yield \"mmdc\"\n    else:\n        yield \"docker\"\n        yield \"run\"\n        yield \"--rm\"\n        yield \"-v\"\n        yield f\"{tmp_root}:{opts.mermaid_volume_mount}\"\n        yield opts.mermaid_docker_image\n\n    yield \"-t\"\n    yield opts.theme\n    yield \"-b\"\n    yield opts.background\n    yield \"-s\"\n    yield str(opts.scale)\n    yield \"-w\"\n    yield str(opts.render_width)\n    yield from (() if opts.render_height is None else (\"-H\", str(opts.render_height)))\n    yield \"-i\"\n    yield tmp_inp.name\n    yield \"-o\"\n    yield tmp_out.name\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.MermaidOptions","title":"<code>MermaidOptions</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Options</code></p> <p>Specific options for the mermaid callback function.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@dataclass\nclass MermaidOptions(Options):\n    \"\"\"\n    Specific options for the mermaid callback function.\n    \"\"\"\n\n    #: The theme to use for the diagram.\n    theme: str = \"default\"\n    #: A scaling factor for the diagram.\n    scale: int = 3\n    #: The width of the diagram in pixels.\n    render_width: int = 800\n    #: The height of the diagram in pixels.\n    render_height: int | None = None\n    #: The background color of the generated diagram.\n    background: str = \"white\"\n    #: The docker image containing the mermaid-cli tool.\n    mermaid_docker_image: str = \"minlag/mermaid-cli\"\n    #: The directory in the docker container to mount the temporary directory to.\n    mermaid_volume_mount: str = \"/data\"\n    #: Whether to use the docker image or a locally installed mermaid-cli tool named mmdc.\n    use_local_mmdc_instead: bool = False\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.Options","title":"<code>Options</code>  <code>dataclass</code>","text":"<p>Specific options for a callback function.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@dataclass\nclass Options:\n    \"\"\"\n    Specific options for a callback function.\n    \"\"\"\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.RunCommandInTempDir","title":"<code>RunCommandInTempDir</code>","text":"<p>A wrapper to run a command in a temporary directory.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>class RunCommandInTempDir:\n    \"\"\"\n    A wrapper to run a command in a temporary directory.\n    \"\"\"\n\n    #: The extension for raw input files.\n    RAW_INPUT_EXT: ClassVar[str] = \"\"\n    #: The valid extensions for output files.\n    VALID_OUT_EXT: ClassVar[frozenset[str]] = frozenset(())\n\n    @staticmethod\n    def preprocess(inp: str, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Preprocess the input string.\n\n        Args:\n            inp: The input string.\n\n        Returns:\n            str: The preprocessed input string.\n        \"\"\"\n        return inp\n\n    def command(self, *, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; Generator[str, None, None]:\n        \"\"\"\n        Generate the command to run.\n\n        Args:\n            tmp_inp: The input file, located in the temporary directory.\n            tmp_out: The output file, located in the temporary directory.\n            tmp_root: The current temporary directory.\n            kwargs: Additional keyword arguments.\n\n        Yields:\n            str: The command strings that were generated.\n        \"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def finalize(*, out: Path, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Finalize the output file.\n\n        Args:\n            out: The output file.\n            tmp_inp: The input file, located in the temporary directory.\n            tmp_out: The output file, located in the temporary directory.\n            tmp_root: The current temporary directory.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The finalized output file.\n        \"\"\"\n        if not tmp_out.exists():\n            raise FileNotFoundError(tmp_out)\n\n        shutil.copy(tmp_out, out)\n\n    def __call__(\n        self, *, inp: Path | str, out: Path, temp_dir: Path | None = None, delete_temp_dir: bool = True, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"\n        Run the command in a temporary directory.\n\n        Args:\n            inp: The input file or a raw input string.\n            out: The output file.\n            temp_dir: A temporary directory to use for intermediate files.\n            delete_temp_dir: Whether to delete the temporary directory after execution.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        out = Path(out)\n\n        with handle_temp_root(temp_dir, delete_temp_dir) as tmp_root:\n            if isinstance(inp, str):\n                tmp_inp = tmp_root / out.with_suffix(self.RAW_INPUT_EXT).name\n                with tmp_inp.open(\"w\") as stream:\n                    stream.write(self.preprocess(inp))\n            else:\n                if not inp.exists():\n                    raise FileNotFoundError(f\"input file does not exist!: {inp}\")\n\n                tmp_inp = tmp_root / inp.name\n                with tmp_inp.open(\"w\") as stream:\n                    stream.write(self.preprocess(inp.read_text()))\n\n            if not out.parent.exists():\n                raise FileNotFoundError(f\"output directory does not exist!: {out.parent}\")\n\n            if out.is_dir():\n                raise IsADirectoryError(out)\n\n            tmp_out = tmp_root / out.name\n            if tmp_out.exists():\n                raise FileExistsError(tmp_out)\n\n            if tmp_out.suffix.lower() not in self.VALID_OUT_EXT:\n                raise ValueError(\n                    f\"Expected output file to have a {', '.join(self.VALID_OUT_EXT)} extension, got {tmp_out.suffix}\"\n                )\n\n            if tmp_inp.suffix.lower() not in {self.RAW_INPUT_EXT}:\n                raise ValueError(f\"Expected input file to have a .mmd extension, got {tmp_inp.suffix}\")\n\n            run(self.command(tmp_inp=tmp_inp, tmp_out=tmp_out, tmp_root=tmp_root, **kwargs), check=True)\n            self.finalize(out=out, tmp_inp=tmp_inp, tmp_out=tmp_out, tmp_root=tmp_root, **kwargs)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.RunCommandInTempDir.__call__","title":"<code>__call__(*, inp, out, temp_dir=None, delete_temp_dir=True, **kwargs)</code>","text":"<p>Run the command in a temporary directory.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>Path | str</code> <p>The input file or a raw input string.</p> required <code>out</code> <code>Path</code> <p>The output file.</p> required <code>temp_dir</code> <code>Path | None</code> <p>A temporary directory to use for intermediate files.</p> <code>None</code> <code>delete_temp_dir</code> <code>bool</code> <p>Whether to delete the temporary directory after execution.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>def __call__(\n    self, *, inp: Path | str, out: Path, temp_dir: Path | None = None, delete_temp_dir: bool = True, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Run the command in a temporary directory.\n\n    Args:\n        inp: The input file or a raw input string.\n        out: The output file.\n        temp_dir: A temporary directory to use for intermediate files.\n        delete_temp_dir: Whether to delete the temporary directory after execution.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    out = Path(out)\n\n    with handle_temp_root(temp_dir, delete_temp_dir) as tmp_root:\n        if isinstance(inp, str):\n            tmp_inp = tmp_root / out.with_suffix(self.RAW_INPUT_EXT).name\n            with tmp_inp.open(\"w\") as stream:\n                stream.write(self.preprocess(inp))\n        else:\n            if not inp.exists():\n                raise FileNotFoundError(f\"input file does not exist!: {inp}\")\n\n            tmp_inp = tmp_root / inp.name\n            with tmp_inp.open(\"w\") as stream:\n                stream.write(self.preprocess(inp.read_text()))\n\n        if not out.parent.exists():\n            raise FileNotFoundError(f\"output directory does not exist!: {out.parent}\")\n\n        if out.is_dir():\n            raise IsADirectoryError(out)\n\n        tmp_out = tmp_root / out.name\n        if tmp_out.exists():\n            raise FileExistsError(tmp_out)\n\n        if tmp_out.suffix.lower() not in self.VALID_OUT_EXT:\n            raise ValueError(\n                f\"Expected output file to have a {', '.join(self.VALID_OUT_EXT)} extension, got {tmp_out.suffix}\"\n            )\n\n        if tmp_inp.suffix.lower() not in {self.RAW_INPUT_EXT}:\n            raise ValueError(f\"Expected input file to have a .mmd extension, got {tmp_inp.suffix}\")\n\n        run(self.command(tmp_inp=tmp_inp, tmp_out=tmp_out, tmp_root=tmp_root, **kwargs), check=True)\n        self.finalize(out=out, tmp_inp=tmp_inp, tmp_out=tmp_out, tmp_root=tmp_root, **kwargs)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.RunCommandInTempDir.command","title":"<code>command(*, tmp_inp, tmp_out, tmp_root, **kwargs)</code>","text":"<p>Generate the command to run.</p> <p>Parameters:</p> Name Type Description Default <code>tmp_inp</code> <code>Path</code> <p>The input file, located in the temporary directory.</p> required <code>tmp_out</code> <code>Path</code> <p>The output file, located in the temporary directory.</p> required <code>tmp_root</code> <code>Path</code> <p>The current temporary directory.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Yields:</p> Name Type Description <code>str</code> <code>str</code> <p>The command strings that were generated.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>def command(self, *, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; Generator[str, None, None]:\n    \"\"\"\n    Generate the command to run.\n\n    Args:\n        tmp_inp: The input file, located in the temporary directory.\n        tmp_out: The output file, located in the temporary directory.\n        tmp_root: The current temporary directory.\n        kwargs: Additional keyword arguments.\n\n    Yields:\n        str: The command strings that were generated.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.RunCommandInTempDir.finalize","title":"<code>finalize(*, out, tmp_inp, tmp_out, tmp_root, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Finalize the output file.</p> <p>Parameters:</p> Name Type Description Default <code>out</code> <code>Path</code> <p>The output file.</p> required <code>tmp_inp</code> <code>Path</code> <p>The input file, located in the temporary directory.</p> required <code>tmp_out</code> <code>Path</code> <p>The output file, located in the temporary directory.</p> required <code>tmp_root</code> <code>Path</code> <p>The current temporary directory.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>The finalized output file.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@staticmethod\ndef finalize(*, out: Path, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Finalize the output file.\n\n    Args:\n        out: The output file.\n        tmp_inp: The input file, located in the temporary directory.\n        tmp_out: The output file, located in the temporary directory.\n        tmp_root: The current temporary directory.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The finalized output file.\n    \"\"\"\n    if not tmp_out.exists():\n        raise FileNotFoundError(tmp_out)\n\n    shutil.copy(tmp_out, out)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.RunCommandInTempDir.preprocess","title":"<code>preprocess(inp, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Preprocess the input string.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>The input string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The preprocessed input string.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@staticmethod\ndef preprocess(inp: str, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Preprocess the input string.\n\n    Args:\n        inp: The input string.\n\n    Returns:\n        str: The preprocessed input string.\n    \"\"\"\n    return inp\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.TikZCallback","title":"<code>TikZCallback</code>","text":"<p>             Bases: <code>RunCommandInTempDir</code></p> <p>A callback function for generating mermaid diagrams.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>class TikZCallback(RunCommandInTempDir):\n    \"\"\"\n    A callback function for generating mermaid diagrams.\n    \"\"\"\n\n    #: The extension for raw input files.\n    RAW_INPUT_EXT: ClassVar[str] = \".tex\"\n    #: The valid extensions for output files.\n    VALID_OUT_EXT: ClassVar[frozenset[str]] = frozenset((\".pdf\", \".svg\", \".png\"))\n\n    @staticmethod\n    def preprocess(inp: str, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Preprocess the input string.\n\n        Args:\n            inp: The input string.\n\n        Returns:\n            str: The preprocessed input string.\n        \"\"\"\n        opts = TikZOptions(**kwargs)\n\n        if \"documentclass\" not in inp:\n            rendered = env().get_template(\"tikz.tex\").render(**asdict(opts), inp=inp.rstrip())\n            logger.debug(\"\\n%s\", rendered)\n            return rendered\n\n        return inp\n\n    def command(self, *, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; Generator[str, None, None]:\n        \"\"\"\n        Generate the command to run.\n\n        Args:\n            tmp_inp: The input file, located in the temporary directory.\n            tmp_out: The output file, located in the temporary directory.\n            tmp_root: The current temporary directory.\n            kwargs: Additional keyword arguments.\n\n        Yields:\n            str: The command strings that were generated.\n        \"\"\"\n        opts = TikZOptions(**kwargs)\n\n        if opts.latex_command and not has_tool(opts.latex_command[0]):\n            if opts.allow_missing:\n                yield \"echo\"\n                yield \"Skipping tectonic command because it is not found.\"\n\n            raise FileNotFoundError(opts.latex_command[0])\n\n        for command in opts.latex_command:\n            yield command.format(inp_tex=tmp_inp)\n\n    @classmethod\n    def finalize(cls, *, out: Path, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Finalize the output file.\n        \"\"\"\n        opts = TikZOptions(**kwargs)\n\n        if tmp_out.suffix.lower() == \".svg\":\n            cls._handle_pdf_to_svg(opts, out, tmp_out)\n        elif tmp_out.suffix.lower() == \".png\":\n            cls._handle_pdf_to_png(opts, out, tmp_out)\n        else:\n            shutil.copy(tmp_out, out)\n\n    @staticmethod\n    def _handle_pdf_to_svg(opts: TikZOptions, out: Path, tmp_out: Path) -&gt; None:\n        args: dict[str, Any] = {\"inp_pdf\": tmp_out.with_suffix(\".pdf\"), \"out_svg\": tmp_out}\n        command = [c.format(**args) for c in opts.pdf2svg_command]\n        if command and has_tool(command[0]):\n            run(command, check=True)\n            shutil.copy(tmp_out, out)\n        else:\n            if not opts.allow_missing:\n                raise FileNotFoundError(\"command not found\")\n\n    @staticmethod\n    def _handle_pdf_to_png(opts: TikZOptions, out: Path, tmp_out: Path) -&gt; None:\n        args: dict[str, Any] = {\n            \"inp_pdf\": tmp_out.with_suffix(\".pdf\"),\n            \"out_png\": tmp_out,\n            \"density\": str(opts.convert_command_density),\n        }\n        command = [c.format(**args) for c in opts.convert_command]\n        if command and has_tool(command[0]):\n            run(command, check=True)\n            shutil.copy(tmp_out, out)\n        else:\n            if not opts.allow_missing:\n                raise FileNotFoundError(\"command not found\")\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.TikZCallback.command","title":"<code>command(*, tmp_inp, tmp_out, tmp_root, **kwargs)</code>","text":"<p>Generate the command to run.</p> <p>Parameters:</p> Name Type Description Default <code>tmp_inp</code> <code>Path</code> <p>The input file, located in the temporary directory.</p> required <code>tmp_out</code> <code>Path</code> <p>The output file, located in the temporary directory.</p> required <code>tmp_root</code> <code>Path</code> <p>The current temporary directory.</p> required <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Yields:</p> Name Type Description <code>str</code> <code>str</code> <p>The command strings that were generated.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>def command(self, *, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; Generator[str, None, None]:\n    \"\"\"\n    Generate the command to run.\n\n    Args:\n        tmp_inp: The input file, located in the temporary directory.\n        tmp_out: The output file, located in the temporary directory.\n        tmp_root: The current temporary directory.\n        kwargs: Additional keyword arguments.\n\n    Yields:\n        str: The command strings that were generated.\n    \"\"\"\n    opts = TikZOptions(**kwargs)\n\n    if opts.latex_command and not has_tool(opts.latex_command[0]):\n        if opts.allow_missing:\n            yield \"echo\"\n            yield \"Skipping tectonic command because it is not found.\"\n\n        raise FileNotFoundError(opts.latex_command[0])\n\n    for command in opts.latex_command:\n        yield command.format(inp_tex=tmp_inp)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.TikZCallback.finalize","title":"<code>finalize(*, out, tmp_inp, tmp_out, tmp_root, **kwargs)</code>  <code>classmethod</code>","text":"<p>Finalize the output file.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@classmethod\ndef finalize(cls, *, out: Path, tmp_inp: Path, tmp_out: Path, tmp_root: Path, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Finalize the output file.\n    \"\"\"\n    opts = TikZOptions(**kwargs)\n\n    if tmp_out.suffix.lower() == \".svg\":\n        cls._handle_pdf_to_svg(opts, out, tmp_out)\n    elif tmp_out.suffix.lower() == \".png\":\n        cls._handle_pdf_to_png(opts, out, tmp_out)\n    else:\n        shutil.copy(tmp_out, out)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.TikZCallback.preprocess","title":"<code>preprocess(inp, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Preprocess the input string.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>The input string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The preprocessed input string.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@staticmethod\ndef preprocess(inp: str, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Preprocess the input string.\n\n    Args:\n        inp: The input string.\n\n    Returns:\n        str: The preprocessed input string.\n    \"\"\"\n    opts = TikZOptions(**kwargs)\n\n    if \"documentclass\" not in inp:\n        rendered = env().get_template(\"tikz.tex\").render(**asdict(opts), inp=inp.rstrip())\n        logger.debug(\"\\n%s\", rendered)\n        return rendered\n\n    return inp\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.TikZOptions","title":"<code>TikZOptions</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Options</code></p> <p>Specific options for the tikz callback function.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@dataclass\nclass TikZOptions(Options):\n    \"\"\"\n    Specific options for the tikz callback function.\n    \"\"\"\n\n    #: Allow commands to be missing?\n    allow_missing: bool = field(\n        default_factory=lambda: os.environ.get(\"JINJA2_MERMAID_EXTENSION_ALLOW_MISSING_COMMANDS\", \"0\").lower()\n        in {\"1\", \"true\"}\n    )\n\n    #: The commands to run to generate the LaTeX output.\n    latex_command: tuple[str, ...] = (\n        \"tectonic\",\n        \"{inp_tex}\",\n    )\n\n    #: The commands to run to generate the SVG output.\n    pdf2svg_command: tuple[str, ...] = (\n        \"pdf2svg\",\n        \"{inp_pdf}\",\n        \"{out_svg}\",\n    )\n\n    #: The commands to run to generate the PNG output.\n    convert_command: tuple[str, ...] = (\n        \"magick\",\n        \"convert\",\n        \"-density\",\n        \"{density}\",\n        \"{inp_pdf}\",\n        \"{out_png}\",\n    )\n\n    #: The DPI to use for the PNG output.\n    convert_command_density: int = 300\n\n    # The following options are used when the input does not explicitly configure the documentclass.\n\n    #: The LaTeX packages to include.\n    packages: tuple[str, ...] = (\"xcolor\", \"tikz\")\n    #: The LaTeX preamble to include.\n    preamble: str = \"\"\n    #: The tikz libraries to include.\n    libraries: tuple[str, ...] = (\"shapes\", \"arrows\", \"decorations\", \"positioning\", \"patterns\", \"calc\")\n    #: The tikz picture options to use.\n    tikz_options: tuple[str, ...] = (\"scale=1\", \"remember picture\")\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.env","title":"<code>env()</code>  <code>cached</code>","text":"<p>Get the Jinja2 environment.</p> <p>Returns:</p> Name Type Description <code>Environment</code> <code>Environment</code> <p>The Jinja2 environment.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@functools.lru_cache(maxsize=1)\ndef env() -&gt; Environment:\n    \"\"\"\n    Get the Jinja2 environment.\n\n    Returns:\n        Environment: The Jinja2 environment.\n    \"\"\"\n    return Environment(loader=PackageLoader(\"jinja2_mermaid_extension\", \"templates\"))  # noqa: S701\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.handle_temp_root","title":"<code>handle_temp_root(force, delete_temp_dir)</code>","text":"<p>Handle the temporary root directory.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>Path | None</code> <p>A forced temporary root directory.</p> required <code>delete_temp_dir</code> <code>bool</code> <p>Whether to delete the temporary directory after execution.</p> required <p>Yields:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The temporary root directory.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@contextmanager\ndef handle_temp_root(force: Path | None, delete_temp_dir: bool) -&gt; Generator[Path, None, None]:\n    \"\"\"\n    Handle the temporary root directory.\n\n    Args:\n        force: A forced temporary root directory.\n        delete_temp_dir: Whether to delete the temporary directory after execution.\n\n    Yields:\n        Path: The temporary root directory.\n    \"\"\"\n    try:\n        if force:\n            yield force\n        else:\n            with TemporaryDirectory(delete=delete_temp_dir) as tmp_root:\n                yield Path(tmp_root)\n    finally:\n        pass\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.callback.has_tool","title":"<code>has_tool(command)</code>  <code>cached</code>","text":"<p>Check if a command is available on the system.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the command is available, False otherwise.</p> Source code in <code>jinja2_mermaid_extension/callback.py</code> <pre><code>@functools.lru_cache\ndef has_tool(command: str) -&gt; bool:\n    \"\"\"\n    Check if a command is available on the system.\n\n    Args:\n        command: The command to check.\n\n    Returns:\n        bool: True if the command is available, False otherwise.\n    \"\"\"\n    return shutil.which(command) is not None\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.extension--this-module-defines-a-jinja2-extension-for-generating-mermaid-diagrams","title":"This module defines a jinja2 extension for generating mermaid diagrams.","text":""},{"location":"modules/#jinja2_mermaid_extension.extension.MermaidExtension","title":"<code>MermaidExtension</code>","text":"<p>             Bases: <code>GenImageExtension</code></p> <p>A Jinja2 extension for generating mermaid diagrams.</p> Source code in <code>jinja2_mermaid_extension/extension.py</code> <pre><code>class MermaidExtension(GenImageExtension):\n    \"\"\"\n    A Jinja2 extension for generating mermaid diagrams.\n    \"\"\"\n\n    tags: set[str] = {\"mermaid\"}  # noqa: RUF012\n    input_root_key: str | None = \"mermaid_input_root\"\n    output_root_key: str | None = \"mermaid_output_root\"\n\n    def __init__(self, environment: Environment):\n        super().__init__(environment)\n\n    @property\n    def _valid_keys(self) -&gt; Generator[str]:\n        yield from MermaidOptions.__annotations__.keys()\n        yield from inspect.signature(mermaid).parameters\n\n    @staticmethod\n    def modify(**kwargs: Any) -&gt; Generator[tuple[str, Any], None, None]:\n        \"\"\"\n        Intercept and modify the keyword arguments before passing them to the callback function.\n        \"\"\"\n        for key, value in kwargs.items():\n            if key == \"diagram\":\n                if \"inp\" in kwargs:\n                    raise RuntimeError(\"Cannot have both 'diagram' and 'inp' in kwargs\")\n                yield \"inp\", value\n            else:\n                yield key, value\n\n    def callback(\n        self,\n        inp: Path | str,\n        out: Path,\n        inp_root: Path,\n        out_root: Path,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The function to call to generate an image.\n        \"\"\"\n        if isinstance(inp, str) and inp.endswith(\".mmd\"):\n            inp = Path(inp)\n            if not inp.is_absolute():\n                inp = inp_root / inp\n\n        return mermaid(inp=inp, out=out, **kwargs)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.extension.MermaidExtension.callback","title":"<code>callback(inp, out, inp_root, out_root, **kwargs)</code>","text":"<p>The function to call to generate an image.</p> Source code in <code>jinja2_mermaid_extension/extension.py</code> <pre><code>def callback(\n    self,\n    inp: Path | str,\n    out: Path,\n    inp_root: Path,\n    out_root: Path,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The function to call to generate an image.\n    \"\"\"\n    if isinstance(inp, str) and inp.endswith(\".mmd\"):\n        inp = Path(inp)\n        if not inp.is_absolute():\n            inp = inp_root / inp\n\n    return mermaid(inp=inp, out=out, **kwargs)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.extension.MermaidExtension.modify","title":"<code>modify(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Intercept and modify the keyword arguments before passing them to the callback function.</p> Source code in <code>jinja2_mermaid_extension/extension.py</code> <pre><code>@staticmethod\ndef modify(**kwargs: Any) -&gt; Generator[tuple[str, Any], None, None]:\n    \"\"\"\n    Intercept and modify the keyword arguments before passing them to the callback function.\n    \"\"\"\n    for key, value in kwargs.items():\n        if key == \"diagram\":\n            if \"inp\" in kwargs:\n                raise RuntimeError(\"Cannot have both 'diagram' and 'inp' in kwargs\")\n            yield \"inp\", value\n        else:\n            yield key, value\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.extension.TikZExtension","title":"<code>TikZExtension</code>","text":"<p>             Bases: <code>GenImageExtension</code></p> <p>A Jinja2 extension for generating tikz diagrams.</p> Source code in <code>jinja2_mermaid_extension/extension.py</code> <pre><code>class TikZExtension(GenImageExtension):\n    \"\"\"\n    A Jinja2 extension for generating tikz diagrams.\n    \"\"\"\n\n    tags: set[str] = {\"tikz\"}  # noqa: RUF012\n    input_root_key: str | None = \"tikz_input_root\"\n    output_root_key: str | None = \"tikz_output_root\"\n\n    def __init__(self, environment: Environment):\n        super().__init__(environment)\n\n    @property\n    def _valid_keys(self) -&gt; Generator[str]:\n        yield from TikZOptions.__annotations__.keys()\n        yield from inspect.signature(tikz).parameters\n\n    @staticmethod\n    def modify(**kwargs: Any) -&gt; Generator[tuple[str, Any], None, None]:\n        \"\"\"\n        Intercept and modify the keyword arguments before passing them to the callback function.\n        \"\"\"\n        for key, value in kwargs.items():\n            if key == \"diagram\":\n                if \"inp\" in kwargs:\n                    raise RuntimeError(\"Cannot have both 'diagram' and 'inp' in kwargs\")\n                yield \"inp\", value\n            else:\n                yield key, value\n\n    def callback(\n        self,\n        inp: Path | str,\n        out: Path,\n        inp_root: Path,\n        out_root: Path,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        The function to call to generate an image.\n        \"\"\"\n        if isinstance(inp, str) and inp.endswith(\".tex\"):\n            inp = Path(inp)\n            if not inp.is_absolute():\n                inp = inp_root / inp\n\n        return tikz(inp=inp, out=out, **kwargs)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.extension.TikZExtension.callback","title":"<code>callback(inp, out, inp_root, out_root, **kwargs)</code>","text":"<p>The function to call to generate an image.</p> Source code in <code>jinja2_mermaid_extension/extension.py</code> <pre><code>def callback(\n    self,\n    inp: Path | str,\n    out: Path,\n    inp_root: Path,\n    out_root: Path,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    The function to call to generate an image.\n    \"\"\"\n    if isinstance(inp, str) and inp.endswith(\".tex\"):\n        inp = Path(inp)\n        if not inp.is_absolute():\n            inp = inp_root / inp\n\n    return tikz(inp=inp, out=out, **kwargs)\n</code></pre>"},{"location":"modules/#jinja2_mermaid_extension.extension.TikZExtension.modify","title":"<code>modify(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Intercept and modify the keyword arguments before passing them to the callback function.</p> Source code in <code>jinja2_mermaid_extension/extension.py</code> <pre><code>@staticmethod\ndef modify(**kwargs: Any) -&gt; Generator[tuple[str, Any], None, None]:\n    \"\"\"\n    Intercept and modify the keyword arguments before passing them to the callback function.\n    \"\"\"\n    for key, value in kwargs.items():\n        if key == \"diagram\":\n            if \"inp\" in kwargs:\n                raise RuntimeError(\"Cannot have both 'diagram' and 'inp' in kwargs\")\n            yield \"inp\", value\n        else:\n            yield key, value\n</code></pre>"}]}